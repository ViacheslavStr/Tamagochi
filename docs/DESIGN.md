# Электронный ребёнок — техническое решение

## 1. Концепция продукта

Пара загружает фото/видео и заполняет анкету → ИИ формирует модель «ребёнка» (внешность + базовые черты) → ребёнок «живёт» в приложении: растёт, общается, выражает эмоции в зависимости от возраста и воспитания.

---

## 2. Блок-схема системы

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         РОДИТЕЛИ (онбординг)                             │
├─────────────────────────────────────────────────────────────────────────┤
│  Фото/видео отца  │  Фото/видео матери  │  Анкета (гены/характер)        │
└────────┬──────────┴──────────┬──────────┴────────────┬───────────────────┘
         │                    │                       │
         ▼                    ▼                       ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                    ГЕНЕРАЦИЯ МОДЕЛИ РЕБЁНКА                               │
│  • Генерация лица (face morph / child prediction)                        │
│  • Вывод базовых характеристик из анкеты                                 │
│  • Начальное состояние: возраст 0, личность, здоровье                   │
└─────────────────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                    «ЖИВОЙ» РЕБЁНОК (runtime)                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐                   │
│  │ Состояние    │  │ Визуал       │  │ Диалог       │                   │
│  │ (возраст,    │  │ (аватар,     │  │ (LLM +       │                   │
│  │  эмоции,     │  │  эмоции,     │  │  память,     │                   │
│  │  память)     │  │  озвучка)    │  │  контекст)   │                   │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘                   │
│         │                 │                  │                            │
│         └─────────────────┴──────────────────┘                            │
│                           │                                               │
│                    Симуляция времени (рост, развитие)                       │
└─────────────────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                    ИНТЕРФЕЙС ДЛЯ РОДИТЕЛЕЙ                                │
│  Просмотр ребёнка │ Чат │ Обучение (слова, действия) │ Настройки          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 3. Технологический стек

### 3.0 Выбор бэкенда: Next.js API Routes vs NestJS

| Критерий | Next.js (фронт + API Routes) | NestJS (отдельный бэкенд) |
|----------|------------------------------|----------------------------|
| **Один репозиторий / деплой** | Один проект, один хост (Vercel и др.) | Два приложения: Next.js + NestJS, два деплоя |
| **Структура и масштаб** | API Routes — файлы в `app/api/`, быстро растут при большом числе эндпоинтов | Модули, контроллеры, сервисы, DI — удобно при большом бэкенде и команде |
| **Валидация, guards, пайпы** | Делаете сами (Zod и т.п.) в каждом route | Встроено: ValidationPipe, guards, interceptors |
| **Очереди, фоновые задачи** | Внешние сервисы (Inngest, Vercel Background, Bull на отдельном воркере) | Удобно встроить Bull/BullMQ в тот же процесс или отдельный воркер |
| **Типизация и контракты** | TypeScript общий с фронтом | Отдельный кодбейз, можно шарить типы через пакет |
| **Порог входа** | Ниже, если уже знаете Next.js | Выше: модульность, декораторы, Nest-специфика |

**Рекомендация для данного продукта:** целиться в **рост продукта**, а не только MVP. Уже заложены требования: **крон-задачи** (симуляция времени, напоминания, периодические проверки состояния ребёнка), **много эндпоинтов** по мере развития, **несколько разработчиков**, **WebSocket** (например, ребёнок «очень хочет позвать папу» — push-уведомление родителю в реальном времени). При таких вводных **бэкенд на NestJS** предпочтителен с самого начала: модульность, встроенная поддержка cron (`@nestjs/schedule`), WebSocket-шлюз, очереди (BullMQ), удобное разделение зон ответственности в команде. **Фронтенд — Next.js** (только UI), бэкенд — **NestJS** (API, крон, сокеты, очереди). Вариант «всё в Next.js» оставляют только если решат стартовать максимально быстро с одним репозиторием и позже вынести бэкенд в NestJS.

### 3.0а Готовые API vs свои модели: плюсы и минусы

Использование **готовых API** (Replicate, OpenAI, D-ID и т.д.) — нормальная и часто оптимальная стратегия. Ниже — сжатое сравнение.

**Плюсы готовых API**

- **Скорость выхода:** не нужно собирать датасеты, обучать и дообучать модели, настраивать инфраструктуру (GPU, оркестрация).
- **Качество:** модели уже обучены на больших данных и поддерживаются провайдером; уровень качества зачастую выше, чем у самописного решения на скромных ресурсах.
- **Масштаб и надёжность:** провайдер отвечает за доступность, апдейты моделей, частично за безопасность.
- **Предсказуемые затраты на старте:** платите по факту использования, без больших фиксированных расходов на железо и ML-команду.
- **Фокус на продукте:** команда занимается логикой приложения, UX и интеграциями, а не ML-пайплайнами.

**Минусы готовых API**

- **Зависимость от провайдера:** изменения цен, лимитов, отключение API или смена условий; нужна абстракция в коде (свой слой над «генерация лица» / «чат»), чтобы при необходимости подменить провайдера.
- **Ограничения по кастомизации:** нельзя «допилить» модель под свою задачу так же гибко, как свою; только промпты, параметры и выбор моделей.
- **Конфиденциальность и юрисдикция:** данные (фото, текст) уходят на сторону провайдера; для чувствительных сценариев нужно учитывать политики и, при необходимости, искать провайдеров с нужными гарантиями или онпрем-решения.
- **Стоимость при большом трафике:** при очень больших объёмах свои модели на своём железе могут стать дешевле; для старта и среднего трафика обычно выгоднее API.
- **Латентность и лимиты:** сетевой вызов, возможные очереди на стороне провайдера; жёсткие rate limits — их нужно учитывать в дизайне (очереди, кэш, fallback).

**Когда свои модели имеют смысл**

- Жёсткие требования к конфиденциальности (данные не должны покидать периметр).
- Очень высокий объём запросов и расчёт, что self-host выйдет дешевле.
- Уникальная задача, для которой нет подходящего готового API, и есть компетенции и ресурсы на обучение/инференс.

**Итог для данного проекта:** использовать **готовые API** — хорошая идея для MVP и дальше: вы быстрее запускаетесь, получаете приемлемое качество без ML-команды. Риски снижаются абстракцией над провайдерами и явной политикой по данным (что храним, куда отправляем). Свои модели рассматривать только при появлении конкретных ограничений (конфиденциальность, масштаб, уникальная модель поведения).

### 3.1 Генерация внешности ребёнка

| Задача | Технологии | Комментарий |
|--------|------------|-------------|
| Лицо ребёнка по фото родителей | **Replicate**: BlendGAN, FLUX PuLID; или исследовательские модели (ChildNet, StyleDiT) по API/self-host | BlendGAN — смешивание стилей лиц; для «ребёнок от двух лиц» могут понадобиться кастомный пайплайн или модель kinship |
| Возрастная прогрессия | **SAM (Sequential Age Mapping)** на Replicate, или фиксированные пресеты по возрастам | Один сгенерированный образ ребёнка → варианты по возрастам (0–1, 1–3, 3–7, 7–12, 12+ условно) |
| Видео из фото (оживление) | **SadTalker**, **Wav2Lip**, **D-ID** (API) | Оживление лица под аудио (TTS) для «живого» общения |

**Рекомендация для MVP:**  
Генерация статичных портретов ребёнка по возрастам (например, 4–5 ключевых возрастов) через Replicate (BlendGAN + SAM или аналог). Оживление — опционально, через SadTalker/D-ID на втором этапе.

### 3.2 Анкета и «генетика»/характер

- **Анкета:** форма в веб-приложении (возраст, рост, телосложение, национальность, образование, интересы, черты характера по типам — Big Five или упрощённая сетка).
- **Маппинг в модель:** правила (или простая модель) переводят ответы в числовые параметры:
  - **Внешность:** вес родителя 1/родителя 2 для морфа, тон кожи, форма лица (если API это поддерживает).
  - **Личность:** вектор черт (открытость, добросовестность, экстраверсия и т.д.) для LLM и симуляции развития.
- Хранение: JSON или поля в БД (профиль отца, профиль матери, результирующий профиль ребёнка).

### 3.3 Состояние ребёнка (модель «жизни»)

- **Хранилище:** PostgreSQL.
- **Сущности:**
  - **Child:** id, id_family, birth_timestamp, current_age_stage, personality_vector, health/happiness (опционально).
  - **Traits:** производные от анкеты + возможные мутации/вариации.
  - **Memory:** ключевые факты из диалогов (краткие предложения + embedding для поиска при ответе).
  - **Events:** важные события (первое слово, обучение навыку) для контекста и сценариев.
- **Время:** симуляция через `current_simulated_date = birth_date + (now - created_at) * time_scale` (например, 1 реальный день = 1 неделя жизни ребёнка). Возрастные стадии переключаются по порогам; обновление можно выполнять по **крон-задаче** (см. п. 4.1).
- **События «ребёнок зовёт родителя»:** симуляция (по правилам или лёгкой модели) решает, что ребёнок «очень хочет внимания»; бэкенд отправляет событие в **WebSocket** — родитель получает push (уведомление, звук) в реальном времени.

### 3.4 Диалог и поведение

| Компонент | Технологии |
|-----------|------------|
| Ядро диалога | **LLM** (OpenAI GPT-4o-mini / Claude Haiku для стоимости; при необходимости — локальный Llama) |
| Персонализация | Системный промпт: возраст ребёнка, стадия развития, черты личности, краткая память (последние N фактов), текущая эмоция |
| Память | Хранение фактов (кто родители, что любят, что уже «выучил»). При запросе — retrieval по последним сообщениям или по embedding |
| Эмоция | Отдельный маленький шаг: по реплике пользователя и контексту выбирается эмоция (радость, грусть, злость, удивление и т.д.) и передаётся в промпт + в визуал |

**Возрастные ограничения:**  
Промпт должен жёстко ограничивать словарь и сложность ответов (лепет → простые слова → короткие фразы → более развёрнутые ответы в зависимости от `age_stage`).

### 3.5 Визуал «живого» ребёнка

- **Вариант A (MVP):** Статичные изображения по возрастам + смена картинки при смене эмоции (набор спрайтов: нейтральный, радость, грусть, сон и т.д.). Можно сгенерировать один базовый портрет и дорисовать эмоции (например, через img2img с промптом эмоции).
- **Вариант B:** Один 3D-аватар (Ready Player Me, или простой rig в Unity/Godot) с блендшейпами под эмоции и озвучку.
- **Вариант C:** Talking head: сгенерированное лицо + SadTalker/Wav2Lip + TTS (OpenAI TTS, ElevenLabs) для озвучивания ответов.

Для «родители могут его видеть» достаточно Варианта A в веб-интерфейсе; B/C — для усиления эффекта «живости».

### 3.6 Рост и развитие

- **Возраст:** обновляется по симулированному времени; при переходе порога — смена `age_stage` и, при необходимости, смена визуала.
- **Обучение:** явные действия родителей («учить слово X», «учить действие Y») сохраняются в Memory/Events и учитываются в промпте (ребёнок «знает» эти слова/действия).
- **Характер:** базовый вектор из анкеты; опционально — лёгкая корректировка от типа взаимодействия (больше похвалы → чуть выше «добросовестность» в следующем сеансе и т.д.).

---

## 4. Рекомендуемая архитектура приложения

Архитектура ориентирована на **рост продукта**: крон-задачи, много эндпоинтов, команда из нескольких человек, WebSocket для событий в реальном времени (например, «ребёнок зовёт папу»). Поэтому **рекомендуемый вариант — раздельный фронт и бэкенд.**

### 4.1 Рекомендуемый вариант: Next.js (фронт) + NestJS (бэкенд)

```
frontend/                 # Next.js — только UI
  app/                    # App Router: онбординг, экран ребёнка, настройки
  (вызовы REST API бэкенда, подписка на WebSocket для push-событий)

backend/                  # NestJS
  src/
    auth/
    families/
    children/
    chat/                  # OpenAI и т.д.
    generate-face/         # Replicate и т.д.
    queue/                 # BullMQ — тяжёлые задачи (генерация лица, TTS)
    schedule/              # @nestjs/schedule — крон-задачи
    events/                # WebSocket Gateway — real-time уведомления
  ...
```

**Крон-задачи (NestJS `@nestjs/schedule`):**
- Обновление симулированного времени и возрастных стадий детей (например, раз в N минут).
- Проверка «состояния» ребёнка (нуждается во внимании, скучает) и постановка в очередь событий «позвать родителя».
- Напоминания родителям (если заложено в продукт).
- Периодическая выгрузка/очистка кэшей, подготовка отчётов и т.п.

**WebSocket (NestJS `@WebSocketGateway`):**
- Родитель при открытии приложения подключается к сокету (по семье/пользователю).
- Когда симуляция решает, что ребёнок «очень хочет позвать папу/маму», бэкенд отправляет событие в сокет — фронт показывает уведомление, можно воспроизвести звук/вибрацию, подсветить экран ребёнка.
- При необходимости через тот же канал можно пушить обновления состояния ребёнка (эмоция, новый контент) без опроса API.

Тяжёлые задачи (генерация лица, TTS) выполняются через **очередь (BullMQ)** в NestJS: API принимает запрос, кладёт задачу в очередь, возвращает id; по готовности можно обновить БД и при необходимости отправить событие по WebSocket.

### 4.2 Альтернатива: один проект Next.js (фронт + API Routes)

Имеет смысл только для самого раннего старта с минимумом функций и одним репозиторием. Кроны и WebSocket тогда выносятся во внешние сервисы (Inngest, Vercel Background, отдельный воркер с сокетами) или эмулируются через polling. При появлении крон-задач и real-time сценариев удобнее перейти на вариант 4.1.

---

## 5. Этапы реализации (кратко)

1. **Этап 1 — Онбординг и генерация:** форма анкеты, загрузка фото, вызов API генерации лица ребёнка (хотя бы один возраст), сохранение профиля и сгенерированных картинок.
2. **Этап 2 — Состояние и время:** модель Child + симуляция времени, смена возрастных стадий и визуала.
3. **Этап 3 — Диалог:** интеграция LLM, системный промпт под возраст и личность, простой чат с ребёнком.
4. **Этап 4 — Память и эмоции:** сохранение фактов, выбор эмоции, отображение эмоции на аватаре.
5. **Этап 5 — Оживление (опционально):** TTS + talking head для озвученных ответов.

---

## 6. Риски и этика

- **Конфиденциальность:** фото и видео родителей — чувствительные данные; хранить зашифрованно, не использовать для обучения сторонних моделей без явного согласия.
- **Этика:** продукт позиционировать как симуляция/развлечение, не как предсказание реального ребёнка; в анкете и интерфейсе явно указывать это.
- **Зависимость от API:** Replicate и LLM-провайдеры могут менять цены и условия; заложить абстракцию (один интерфейс для «генерация лица», один для «LLM»), чтобы при необходимости подменить провайдера.

---

## 7. Итоговая таблица технологий

| Область | Выбор для MVP | Альтернативы |
|---------|----------------|--------------|
| Генерация лица ребёнка | **Replicate** (BlendGAN + SAM или FLUX) — готовый API | Другие API с face generation |
| Фронтенд | **Next.js** (React) | — |
| Бэкенд | **NestJS** (API, крон, WebSocket, очереди) | См. п. 3.0, 4.1 |
| Real-time | **WebSocket** (NestJS Gateway): события «ребёнок зовёт», обновления состояния | — |
| Фоновые/периодические задачи | **@nestjs/schedule** (крон) + **BullMQ** (очереди) | — |
| БД | **PostgreSQL** (Drizzle ORM в NestJS) | — |
| LLM (чат) | **OpenAI** GPT-4o-mini — готовый API | Claude, др. API |
| Память для диалога | Простой список последних фактов или векторный поиск (API embeddings) | — |
| Озвучка | **OpenAI TTS** или ElevenLabs — готовый API | — |
| Оживление лица | D-ID API или др. talking-head API | SadTalker (self-host) |

Если нужно, следующий шаг — набросать структуру репозитория (папки, ключевые файлы) и скелет API для онбординга и чата.
